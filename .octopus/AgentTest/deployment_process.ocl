step "deploy-a-helm-chart" {
    condition = "Always"
    name = "Deploy a Helm Chart"
    properties = {
        Octopus.Action.TargetRoles = "travisl-aks-cluster"
    }

    action {
        action_type = "Octopus.HelmChartUpgrade"
        properties = {
            Octopus.Action.Helm.AdditionalArgs = "--create-namespace --namespace travisl-script-image-test"
            Octopus.Action.Helm.ClientVersion = "V3"
            Octopus.Action.Helm.ReleaseName = "#{Octopus.Environment.Name | ToLower}-nginx-ingress"
            Octopus.Action.Helm.ResetValues = "True"
            Octopus.Action.Package.DownloadOnTentacle = "False"
            Octopus.Action.Package.FeedId = "helm-nginx"
            Octopus.Action.Package.PackageId = "nginx-ingress"
            Octopus.Action.RunOnServer = "false"
            Octopus.Action.Script.ScriptSource = "Package"
        }
        worker_pool_variable = ""

        packages {
            acquisition_location = "Server"
            feed = "helm-nginx"
            package_id = "nginx-ingress"
            properties = {
                SelectionMode = "immediate"
            }
        }
    }
}

step "deploy-kubernetes-yaml" {
    condition = "Always"
    name = "Deploy Kubernetes YAML"
    properties = {
        Octopus.Action.TargetRoles = "travisl-aks-cluster"
    }

    action {
        action_type = "Octopus.KubernetesDeployRawYaml"
        properties = {
            Octopus.Action.Kubernetes.DeploymentTimeout = "180"
            Octopus.Action.Kubernetes.ResourceStatusCheck = "True"
            Octopus.Action.Kubernetes.ServerSideApply.Enabled = "True"
            Octopus.Action.Kubernetes.ServerSideApply.ForceConflicts = "True"
            Octopus.Action.KubernetesContainers.CustomResourceYaml = <<-EOT
                apiVersion: batch/v1
                kind: Job
                metadata:
                  name: pi
                spec:
                  template:
                    spec:
                      containers:
                      - name: pi
                        image: perl:5.34.0
                        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
                      restartPolicy: Never
                  backoffLimit: 4
                EOT
            Octopus.Action.KubernetesContainers.Namespace = "travisl-script-image-test"
            Octopus.Action.RunOnServer = "false"
            Octopus.Action.Script.ScriptSource = "Inline"
        }
        worker_pool_variable = ""
    }
}

step "run-a-kubectl-script" {
    condition = "Always"
    name = "Run a kubectl script"
    properties = {
        Octopus.Action.TargetRoles = "travisl-aks-cluster"
    }

    action {
        action_type = "Octopus.KubernetesRunScript"
        properties = {
            Octopus.Action.KubernetesContainers.Namespace = "travisl-script-image-test"
            Octopus.Action.RunOnServer = "false"
            Octopus.Action.Script.ScriptBody = "kubectl get pods -A"
            Octopus.Action.Script.ScriptSource = "Inline"
            Octopus.Action.Script.Syntax = "PowerShell"
        }
        worker_pool_variable = ""
    }
}

step "deploy-with-kustomize" {
    condition = "Always"
    name = "Deploy with Kustomize"
    properties = {
        Octopus.Action.TargetRoles = "travisl-aks-cluster"
    }

    action {
        action_type = "Octopus.Kubernetes.Kustomize"
        properties = {
            Octopus.Action.GitRepository.Source = "Project"
            Octopus.Action.Kubernetes.DeploymentTimeout = "180"
            Octopus.Action.Kubernetes.Kustomize.OverlayPath = "overlays/dev"
            Octopus.Action.Kubernetes.ResourceStatusCheck = "True"
            Octopus.Action.Kubernetes.ServerSideApply.Enabled = "True"
            Octopus.Action.Kubernetes.ServerSideApply.ForceConflicts = "True"
            Octopus.Action.RunOnServer = "false"
            Octopus.Action.Script.ScriptSource = "GitRepository"
            Octopus.Action.SubstituteInFiles.TargetFiles = "**/*.yaml"
        }
        worker_pool_variable = ""

        packages "nginx" {
            acquisition_location = "NotAcquired"
            feed = "docker-public-read-only"
            package_id = "nginx"
            properties = {
                Extract = "False"
                Purpose = "DockerImageReference"
                SelectionMode = "immediate"
            }
        }
    }
}

step "configure-and-apply-kubernetes-resources" {
    condition = "Always"
    name = "Configure and apply Kubernetes resources"
    properties = {
        Octopus.Action.TargetRoles = "travisl-aks-cluster"
    }

    action {
        action_type = "Octopus.KubernetesDeployContainers"
        properties = {
            Octopus.Action.EnabledFeatures = ",Octopus.Features.KubernetesService,Octopus.Features.KubernetesIngress,Octopus.Features.KubernetesConfigMap,Octopus.Features.KubernetesSecret"
            Octopus.Action.Kubernetes.DeploymentTimeout = "180"
            Octopus.Action.Kubernetes.ResourceStatusCheck = "True"
            Octopus.Action.Kubernetes.ServerSideApply.Enabled = "True"
            Octopus.Action.Kubernetes.ServerSideApply.ForceConflicts = "True"
            Octopus.Action.KubernetesContainers.BackoffLimit = "4"
            Octopus.Action.KubernetesContainers.CombinedVolumes = "[]"
            Octopus.Action.KubernetesContainers.Containers = <<-EOT
                [
                 {
                  "Name": "pi",
                  "Ports": [],
                  "EnvironmentVariables": [],
                  "SecretEnvironmentVariables": [],
                  "ConfigMapEnvironmentVariables": [],
                  "FieldRefEnvironmentVariables": [],
                  "ConfigMapEnvFromSource": [],
                  "SecretEnvFromSource": [],
                  "VolumeMounts": [],
                  "Resources": {
                   "requests": {
                    "memory": "",
                    "cpu": "",
                    "ephemeralStorage": ""
                   },
                   "limits": {
                    "memory": "",
                    "cpu": "",
                    "ephemeralStorage": "",
                    "nvidiaGpu": "",
                    "amdGpu": ""
                   }
                  },
                  "LivenessProbe": {
                   "failureThreshold": "",
                   "initialDelaySeconds": "",
                   "periodSeconds": "",
                   "successThreshold": "",
                   "timeoutSeconds": "",
                   "type": null,
                   "exec": {
                    "command": []
                   },
                   "httpGet": {
                    "host": "",
                    "path": "",
                    "port": "",
                    "scheme": "",
                    "httpHeaders": []
                   },
                   "tcpSocket": {
                    "host": "",
                    "port": ""
                   }
                  },
                  "ReadinessProbe": {
                   "failureThreshold": "",
                   "initialDelaySeconds": "",
                   "periodSeconds": "",
                   "successThreshold": "",
                   "timeoutSeconds": "",
                   "type": null,
                   "exec": {
                    "command": []
                   },
                   "httpGet": {
                    "host": "",
                    "path": "",
                    "port": "",
                    "scheme": "",
                    "httpHeaders": []
                   },
                   "tcpSocket": {
                    "host": "",
                    "port": ""
                   }
                  },
                  "StartupProbe": {
                   "failureThreshold": "",
                   "initialDelaySeconds": "",
                   "periodSeconds": "",
                   "successThreshold": "",
                   "timeoutSeconds": "",
                   "type": null,
                   "exec": {
                    "command": []
                   },
                   "httpGet": {
                    "host": "",
                    "path": "",
                    "port": "",
                    "scheme": "",
                    "httpHeaders": []
                   },
                   "tcpSocket": {
                    "host": "",
                    "port": ""
                   }
                  },
                  "Command": [
                   "perl",
                   "-Mbignum=bpi",
                   "-wle",
                   "print bpi(2000)"
                  ],
                  "Args": [],
                  "InitContainer": "False",
                  "SecurityContext": {
                   "allowPrivilegeEscalation": "",
                   "privileged": "",
                   "readOnlyRootFilesystem": "",
                   "runAsGroup": "",
                   "runAsNonRoot": "",
                   "runAsUser": "",
                   "capabilities": {
                    "add": [],
                    "drop": []
                   },
                   "seLinuxOptions": {
                    "level": "",
                    "role": "",
                    "type": "",
                    "user": ""
                   }
                  },
                  "Lifecycle": {},
                  "CreateFeedSecrets": "True"
                 }
                ]
                EOT
            Octopus.Action.KubernetesContainers.DeploymentAnnotations = "[]"
            Octopus.Action.KubernetesContainers.DeploymentLabels = "{}"
            Octopus.Action.KubernetesContainers.DeploymentName = "pii"
            Octopus.Action.KubernetesContainers.DeploymentResourceType = "Job"
            Octopus.Action.KubernetesContainers.DeploymentStyle = "RollingUpdate"
            Octopus.Action.KubernetesContainers.DnsConfigOptions = "[]"
            Octopus.Action.KubernetesContainers.HostAliases = "[]"
            Octopus.Action.KubernetesContainers.IngressAnnotations = "[]"
            Octopus.Action.KubernetesContainers.Namespace = "#{K8s.Namespace}"
            Octopus.Action.KubernetesContainers.NodeAffinity = "[]"
            Octopus.Action.KubernetesContainers.PersistentVolumeClaims = "[]"
            Octopus.Action.KubernetesContainers.PodAffinity = "[]"
            Octopus.Action.KubernetesContainers.PodAnnotations = "[]"
            Octopus.Action.KubernetesContainers.PodAntiAffinity = "[]"
            Octopus.Action.KubernetesContainers.PodManagementPolicy = "OrderedReady"
            Octopus.Action.KubernetesContainers.PodSecuritySysctls = "[]"
            Octopus.Action.KubernetesContainers.Replicas = "1"
            Octopus.Action.KubernetesContainers.RestartPolicy = "Never"
            Octopus.Action.KubernetesContainers.ServiceNameType = "External"
            Octopus.Action.KubernetesContainers.ServiceType = "ClusterIP"
            Octopus.Action.KubernetesContainers.Tolerations = "[]"
            Octopus.Action.RunOnServer = "false"
        }
        worker_pool_variable = ""

        packages "pi" {
            acquisition_location = "NotAcquired"
            feed = "docker-public-read-only"
            package_id = "perl"
        }
    }
}

step "configure-and-apply-a-kubernetes-configmap" {
    condition = "Always"
    name = "Configure and apply a Kubernetes ConfigMap"
    properties = {
        Octopus.Action.TargetRoles = "travisl-aks-cluster"
    }

    action {
        action_type = "Octopus.KubernetesDeployConfigMap"
        properties = {
            Octopus.Action.Kubernetes.ResourceStatusCheck = "True"
            Octopus.Action.Kubernetes.ServerSideApply.Enabled = "True"
            Octopus.Action.Kubernetes.ServerSideApply.ForceConflicts = "True"
            Octopus.Action.KubernetesContainers.ConfigMapName = "game-demo"
            Octopus.Action.KubernetesContainers.ConfigMapValues = "{\"player_initial_lives\":\"3\",\"ui_properties_file_name\":\"user-interface.properties\",\"game.properties\":\"enemy.types=aliens,monsters\\nplayer.maximum-lives=5    \\n\",\"user-interface.properties\":\"color.good=purple\\ncolor.bad=yellow\\nallow.textmode=true    \\n\"}"
            Octopus.Action.KubernetesContainers.DeploymentLabels = "{}"
            Octopus.Action.KubernetesContainers.Namespace = "#{K8s.Namespace}"
            Octopus.Action.RunOnServer = "false"
        }
        worker_pool_variable = ""
    }
}

step "configure-and-apply-a-kubernetes-service" {
    condition = "Always"
    name = "Configure and apply a Kubernetes Service"
    properties = {
        Octopus.Action.TargetRoles = "travisl-aks-cluster"
    }

    action {
        action_type = "Octopus.KubernetesDeployService"
        properties = {
            Octopus.Action.Kubernetes.DeploymentTimeout = "180"
            Octopus.Action.Kubernetes.ResourceStatusCheck = "True"
            Octopus.Action.Kubernetes.ServerSideApply.Enabled = "True"
            Octopus.Action.Kubernetes.ServerSideApply.ForceConflicts = "True"
            Octopus.Action.KubernetesContainers.DeploymentLabels = "{}"
            Octopus.Action.KubernetesContainers.LoadBalancerAnnotations = "[]"
            Octopus.Action.KubernetesContainers.Namespace = "#{K8s.Namespace}"
            Octopus.Action.KubernetesContainers.SelectorLabels = "{\"app.kubernetes.io/name\":\"dev-kustomize-nginx\"}"
            Octopus.Action.KubernetesContainers.ServiceName = "my-service"
            Octopus.Action.KubernetesContainers.ServicePorts = "[{\"protocol\":\"TCP\",\"port\":\"80\",\"targetPort\":\"9376\"}]"
            Octopus.Action.KubernetesContainers.ServiceType = "ClusterIP"
            Octopus.Action.RunOnServer = "false"
        }
        worker_pool_variable = ""
    }
}

step "configure-and-apply-a-kubernetes-ingress" {
    condition = "Always"
    name = "Configure and apply a Kubernetes Ingress"
    properties = {
        Octopus.Action.TargetRoles = "travisl-aks-cluster"
    }

    action {
        action_type = "Octopus.KubernetesDeployIngress"
        properties = {
            Octopus.Action.Kubernetes.DeploymentTimeout = "180"
            Octopus.Action.Kubernetes.ResourceStatusCheck = "True"
            Octopus.Action.Kubernetes.ServerSideApply.Enabled = "True"
            Octopus.Action.Kubernetes.ServerSideApply.ForceConflicts = "True"
            Octopus.Action.KubernetesContainers.DeploymentLabels = "{}"
            Octopus.Action.KubernetesContainers.IngressAnnotations = "[{\"key\":\"nginx.ingress.kubernetes.io/rewrite-target\",\"value\":\"/\"}]"
            Octopus.Action.KubernetesContainers.IngressClassName = "nginx-example"
            Octopus.Action.KubernetesContainers.IngressName = "minimal-ingress"
            Octopus.Action.KubernetesContainers.IngressRules = "[{\"http\":{\"paths\":[{\"key\":\"/testpath\",\"value\":\"80\",\"option\":\"test\",\"option2\":\"Prefix\"}]}}]"
            Octopus.Action.KubernetesContainers.IngressTlsCertificates = "[]"
            Octopus.Action.KubernetesContainers.Namespace = "#{K8s.Namespace}"
            Octopus.Action.RunOnServer = "false"
        }
        worker_pool_variable = ""
    }
}

step "configure-and-apply-a-kubernetes-secret" {
    condition = "Always"
    name = "Configure and apply a Kubernetes Secret"
    properties = {
        Octopus.Action.TargetRoles = "travisl-aks-cluster"
    }

    action {
        action_type = "Octopus.KubernetesDeploySecret"
        properties = {
            Octopus.Action.Kubernetes.ResourceStatusCheck = "True"
            Octopus.Action.Kubernetes.ServerSideApply.Enabled = "True"
            Octopus.Action.Kubernetes.ServerSideApply.ForceConflicts = "True"
            Octopus.Action.KubernetesContainers.DeploymentLabels = "{}"
            Octopus.Action.KubernetesContainers.Namespace = "#{K8s.Namespace}"
            Octopus.Action.KubernetesContainers.SecretName = "secret-dockercfg"
            Octopus.Action.KubernetesContainers.SecretValues = "{\".dockercfg\":\"{\\\"auths\\\":{\\\"https://example/v1/\\\":{\\\"auth\\\":\\\"opensesame\\\"}}}\\n\"}"
            Octopus.Action.RunOnServer = "false"
        }
        worker_pool_variable = ""
    }
}